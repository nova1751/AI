#!/user/bin/env python3
# -*- coding: utf-8 -*-
import numpy as np

# 广播(Broadcast)是 numpy 对不同形状(shape)的数组进行数值计算的方式， 对数组的算术运算通常在相应的元素上进行。
#
# 如果两个数组 a 和 b 形状相同，即满足 a.shape == b.shape，那么 a*b 的结果就是 a 与 b 数组对应位相乘。
# 这要求维数相同，且各维度的长度相同。
a = np.array([1, 2, 3, 4])
b = np.array([10, 20, 30, 40])
c = a * b
print(c)

# 当运算中的 2 个数组的形状不同时，numpy 将自动触发广播机制。如：
a = np.array([[0, 0, 0], [10, 10, 10], [20, 20, 20], [30, 30, 30]])
b=np.array([0,1,2])
print(a+b)

# 4x3 的二维数组与长为 3 的一维数组相加，等效于把数组 b 在二维上重复 4 次再运算：
a = np.array([[ 0, 0, 0],
           [10,10,10],
           [20,20,20],
           [30,30,30]])
b = np.array([1,2,3])
bb = np.tile(b, (4, 1))  # 重复 b 的各个维度
print(a + bb)

# 广播的规则:
#
# 让所有输入数组都向其中形状最长的数组看齐，形状中不足的部分都通过在前面加 1 补齐。
# 输出数组的形状是输入数组形状的各个维度上的最大值。
# 如果输入数组的某个维度和输出数组的对应维度的长度相同或者其长度为 1 时，这个数组能够用来计算，否则出错。
# 当输入数组的某个维度的长度为 1 时，沿着此维度运算时都用此维度上的第一组值。
# 简单理解：对两个数组，分别比较他们的每一个维度（若其中一个数组没有当前维度则忽略），满足：
#
# 数组拥有相同形状。
# 当前维度的值相等。
# 当前维度的值有一个是 1。
# 若条件不满足，抛出 "ValueError: frames are not aligned" 异常。
# numpy.tile(A , reps)
# 这里的 A 就是数组，reps 可以是一个数，一个列表、元组或者数组等，就是类数组的类型。先要理解准确，先把 A 当作一个块（看作一个整体，别分开研究每个元素）。
#
# （1）如果 reps 是一个数，就是简单的将 A 向右复制 reps - 1 次形成新的数组，就是 reps 个 A 横向排列：
#
# import numpy as np
#
# a = np.array([[1,2],[3,4]],dtype='i1')
# print(a,'\n')
# b = np.tile(a,2)  #向右复制，两个 A 横向排列
# print(b)
# 结果：
#
# [[1 2]
#  [3 4]]
#
# [[1 2 1 2]
#  [3 4 3 4]]
# （2）如果 reps 是一个 array-like（类数组的，如列表，元组，数组）类型的，它有两个元素，如 [m , n]，实际上就是将 A 这个块变成 m * n 个 A 组成的新数组，有 m 行，n 列 A：
#
# import numpy as np
#
# a = np.array([[1,2],[3,4]],dtype='i1')
# print(a,'\n')
# b = np.tile(a,(2,3))  #2 * 3 个 A 组成新数组
# print(b)
# 结果：
#
# [[1 2]
#  [3 4]]
#
# [[1 2 1 2 1 2]
#  [3 4 3 4 3 4]
#  [1 2 1 2 1 2]
#  [3 4 3 4 3 4]]